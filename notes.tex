\documentclass[12pt,a4paper]{article}
\usepackage[top=2cm,left=2cm,right=2cm,bottom=2cm]{geometry}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\hypersetup{
	colorlinks=false,
	linkbordercolor={1 1 1},
	citebordercolor={1 1 1}
}
\usepackage{listings}
\lstset{language=C++,
	basicstyle=\footnotesize,
	showstringspaces=false,
	tabsize=4,
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	breaklines=true,
	extendedchars=true,
	frame=tb
}

\title{sudo make a manual}
\author{sudo make a sandwich}

\begin{document}
	\twocolumn
	\maketitle
	\tableofcontents
	\onecolumn

	\section{Utilidades}
		\subsection{.vimrc}
			\lstinputlisting{misc/vimrc}
		\subsection{Makefile}
			\lstinputlisting{misc/Makefile}
		\subsection{Template}
			\lstinputlisting{algoritmos/template.cpp}
	
	\section{Estruturas de Dados}
		\subsection{Heap Binário}
			Tempo: \( O(\log n) \) em todas as operações.
			\lstinputlisting{algoritmos/heap.cpp}
		\subsection{Union-Find}
			Tempo: \( O(\alpha(n)) \) em todas as operações.
			\lstinputlisting{algoritmos/union-find.cpp}
		\subsection{Lowest Common Ancestor}
			% TODO

	\section{Ordenação}
		\begin{table}[h]
			\centering
			\begin{tabular}{l l l l l}
				\hline\hline
				\bf{Algoritmo}	& \bf{Caso Médio}	& \bf{Pior Caso}	& \bf{Memória}	& \bf{Estável}	\\
				\hline\hline
				Bubble Sort		& \(O(n^2)\)		& \(O(n^2)\)		& \(O(1)\)		& sim			\\
				Insertion Sort	& \(O(n^2)\)		& \(O(n^2)\)		& \(O(1)\)		& sim			\\
				Merge Sort		& \(O(n \log n)\)	& \(O(n \log n)\)	& \(O(n)\)		& sim			\\
				Heapsort		& \(O(n \log n)\)	& \(O(n \log n)\)	& \(O(1)\)		& não			\\
				Quicksort		& \(O(n \log n)\)	& \(O(n^2)\)		& \(O(\log n)\) & não			\\
				\hline
				Counting Sort	& \(O(n + 2^k)\)	& \(O(n + 2^k)\)	& \(O(n + 2^k)\) & sim			\\
				Bucket Sort		& \(O(n \cdot k)\)	& \(O(n^2\cdot k)\)	& \(O(n \cdot k)\) & sim		\\
				\hline\hline
			\end{tabular}
			\caption{Características dos algoritmos de ordenação}
		\end{table}
		\subsection{Bubble Sort}
			\lstinputlisting{algoritmos/bubblesort.cpp}
		\subsection{Merge Sort}
			\lstinputlisting{algoritmos/mergesort.cpp}
		\subsection{Quicksort}
			\lstinputlisting{algoritmos/quicksort.cpp}
		\subsection{Counting Sort}
			\lstinputlisting{algoritmos/countingsort.cpp}
	
	\section{Matemática}
		\subsection{Bigmod}
			Propriedade:
			\[ (A \cdot B \cdot C) \bmod N = ((A \bmod N) \cdot (B \bmod N) \cdot (C \bmod N)) \bmod N \]
			\[ r = b^p \bmod m \]
			\lstinputlisting{algoritmos/bigmod.cpp}
		\subsection{Long Integer}
			\lstinputlisting{algoritmos/bignum.cpp}
		\subsection{Sieve de Números Primos}
			\lstinputlisting{algoritmos/sieve.cpp}
		\subsection{Máximo Divisor Comum}
			\lstinputlisting{algoritmos/gcd.cpp}
		\subsection{Mínimo Múltiplo Comum}
			\lstinputlisting{algoritmos/mmc.cpp}
		\subsection{Algoritmo de Euclides}
			\lstinputlisting{algoritmos/euclides.cpp}
		\subsection{Combinação}
			\[ C_n^k = {n! \over {k! \cdot (n - k)!}} \]
			\lstinputlisting{algoritmos/comb.cpp}
		\subsection{Floyd's Cycle-Finding}
			\lstinputlisting{algoritmos/floydcycle.cpp}

	\section{Grafos}
		\subsection{Strongly Connected Components}
			\subsubsection{Kosaraju}
				Tempo: \( O(V + E) \)
				\lstinputlisting{algoritmos/kosaraju.cpp}
		\subsection{Caminho mínimo}
			\subsubsection{Floyd-Warshall}
				Tempo: \( \Theta(n^3)\)
				\lstinputlisting{algoritmos/floyd-warshall.cpp}
			\subsubsection{Dijkstra}
				Tempo: \( O(|V|^2) \)
				\lstinputlisting{algoritmos/dijkstra.cpp}
			\subsubsection{Dijkstra com Heap}
				Tempo: \( O(|E| + |V| \log |V|) \)
				% TODO
			\subsubsection{Bellman-Ford}
				Tempo: \( O(|V| |E|) \)
				\lstinputlisting{algoritmos/bellman-ford.cpp}
		\subsection{Árvore Geradora Mínima}
			\subsubsection{Prim}
				% TODO
			\subsubsection{Kruskal}
				Tempo: \( O(|E| \log |V|) \) ou \( O(|E| \cdot \alpha(|V|)) \) caso as arestas estejam pré-ordenadas.
				\lstinputlisting{algoritmos/kruskal.cpp}
			\subsubsection{Boruvka}
				% TODO
		\subsection{Fluxo Máximo e Corte Mínimo}
			\subsubsection{Edmonds-Karp}
				Tempo: \( O(n!) \) % TODO: arrumar o tempo
				\lstinputlisting{algoritmos/ford-fulkerson.cpp}
			\subsubsection{Min-Cost Max-Flow}
				Tempo: \( O(n^2 m B) \)
				\lstinputlisting{algoritmos/mincostmaxflow.cpp}
			\subsubsection{Stoer-Wagner}
				Algoritmo para encontrar o corte mínimo (não s-t) em um grafo. A implementação abaixo é \(O(n^3)\).
				\lstinputlisting{algoritmos/stoer-wagner.cpp}
		\subsection{Aresta de Corte}
			\lstinputlisting{algoritmos/bridge.cpp}
		\subsection{Ponto de Articulação}
			\lstinputlisting{algoritmos/pontoart.cpp}
		\subsection{Caminho Euleriano}
			% TODO
		\subsection{Ciclo Euleriano}
			% TODO

	\section{Programação Dinâmica}
		% TODO: colocar mais
		\subsection{Longest Common Subsequence}
			Tempo: \( O(nm) \)
			\lstinputlisting{algoritmos/lcs.cpp}
		\subsection{Matrix-chain Multiplication}
			Tempo: \( O(n^3) \)
			\lstinputlisting{algoritmos/arraymultiplication.cpp}
	
	\section{Geometria Computacional}
		\lstinputlisting{algoritmos/geometry-defs.cpp}
		\subsection{Círculos}
			\lstinputlisting{algoritmos/circle.cpp}
		\subsection{Intersecção de Segmentos}
			\lstinputlisting{algoritmos/segments-intersect.cpp}
		\subsection{Ponto dentro de Polígono}
			\subsubsection{Solução 1}
				Constante de tempo baixa, não faz uso de funções de trigonometria. Retorna \emph{true} se o ponto está sob um dos lados do polígono (facilmente alterável).
				\lstinputlisting{algoritmos/inpoly1.cpp}
		\subsection{Teste de Convexidade}
			Algoritmo para testar se um polígono é convexo ou não.
			% TODO
		\subsection{Área de um Polígono}
			\subsubsection{Convexo}
				Se o polígono está no sentido anti-horário, a área é positiva. Se estiver no sentido horário, a área é negativa.
				\lstinputlisting{algoritmos/convex-area.cpp}
			\subsubsection{Qualquer}
				\lstinputlisting{algoritmos/poly-area.cpp}
		\subsection{Convex Hull}
			\subsubsection{Graham Scan}
				Tempo: \(O(n \log n)\)
				\lstinputlisting{algoritmos/graham-scan.cpp}
			\subsubsection{Jarvis March}
				Tempo: \(O(n h)\)
				\lstinputlisting{algoritmos/jarvis-march.cpp}

	\section{Outros}
		\subsection{Kadane 1D}
			Tempo: \(\Theta(n)\)
			\lstinputlisting{algoritmos/kadane1d.cpp}
		\subsection{Kadane 2D}
			Tempo: \(O(n^3)\)
			\lstinputlisting{algoritmos/kadane2d.cpp}
		\subsection{Stable Marriage}
			Given $n$ men and $n$ women, where each person has ranked all members of the opposite sex with a unique number between $1$ and $n$ in order of preference, marry the men and women off such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \emph{stable}.
			\subsubsection{Gale-Shapley}
				Tempo: \(O(n^2)\)
				\lstinputlisting{algoritmos/stablemarriage.cpp}
		\subsection{Números Romanos}
			\lstinputlisting{algoritmos/romanos.cpp}
		\subsection{Calendário}
			\lstinputlisting{algoritmos/calendario.cpp}

	\twocolumn
	\section{Formulário}
		\subsection{Somatórios}
			\[ \sum_{k = 1}^{n} k = \frac{n \cdot (n + 1)}{2} \]
			\[ \sum_{k = 1}^{n} k^2 = \frac{n \cdot (n + 1) \cdot (2n + 1)}{6} \]
			\[ \sum_{k = 1}^{n} k^3 = \bigg[\frac{n \cdot (n + 1)}{2}\bigg]^2 \]
		\subsection{Geometria}
			\subsubsection{Triângulos}
				\emph{Área, dados lados a, b, c}
				\[ S = \sqrt{p (p - a) (p - b) (p - c)} \]
				\[ p = \frac{a + b + c}{2} \]
				\emph{Área, dadas medianas u, v, w}
				\[ S = \frac{4}{3} \sqrt{q (q - u) (q - v) (q - w)} \]
				\[ q = \frac{u + v + w}{2} \]
\end{document}
