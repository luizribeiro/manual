\documentclass[12pt,a4paper]{article}
\usepackage[top=2cm,left=2cm,right=2cm,bottom=2cm]{geometry}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\hypersetup{
	colorlinks=false,
	linkbordercolor={1 1 1},
	citebordercolor={1 1 1}
}
\usepackage{listings}
\lstset{language=C++,
	basicstyle=\footnotesize,
	showstringspaces=false,
	tabsize=4,
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	breaklines=true,
	extendedchars=true,
	frame=tb
}

\title{sudo make a manual}
\author{sudo make a sandwich}

\begin{document}
	\twocolumn
	\maketitle
	\tableofcontents
	\onecolumn

	\section{Utilidades}
		\subsection{.vimrc}
			\lstinputlisting{misc/vimrc}
		\subsection{Makefile}
			\lstinputlisting{misc/Makefile}
		\subsection{Template}
			\lstinputlisting{algoritmos/template.cpp}
	
	\section{Estruturas de Dados}
		\subsection{Heap Binário}
			Tempo: \( O(\log n) \) em todas as operações.
			\lstinputlisting{algoritmos/heap.cpp}
		\subsection{Union-Find}
			Tempo: \( O(\alpha(n)) \) em todas as operações.
			\lstinputlisting{algoritmos/union-find.cpp}
		\subsection{Lowest Common Ancestor}
			% TODO
		\subsection{Fenwick Tree}
			% TODO

	\section{Ordenação}
		\begin{table}[h]
			\centering
			\begin{tabular}{l l l l l}
				\hline\hline
				\bf{Algoritmo}	& \bf{Caso Médio}	& \bf{Pior Caso}	& \bf{Memória}	& \bf{Estável}	\\
				\hline\hline
				Bubble Sort		& \(O(n^2)\)		& \(O(n^2)\)		& \(O(1)\)		& sim			\\
				Insertion Sort	& \(O(n^2)\)		& \(O(n^2)\)		& \(O(1)\)		& sim			\\
				Merge Sort		& \(O(n \log n)\)	& \(O(n \log n)\)	& \(O(n)\)		& sim			\\
				Heapsort		& \(O(n \log n)\)	& \(O(n \log n)\)	& \(O(1)\)		& não			\\
				Quicksort		& \(O(n \log n)\)	& \(O(n^2)\)		& \(O(\log n)\) & não			\\
				\hline
				Counting Sort	& \(O(n + 2^k)\)	& \(O(n + 2^k)\)	& \(O(n + 2^k)\) & sim			\\
				Bucket Sort		& \(O(n \cdot k)\)	& \(O(n^2\cdot k)\)	& \(O(n \cdot k)\) & sim		\\
				\hline\hline
			\end{tabular}
			\caption{Características dos algoritmos de ordenação}
		\end{table}
		\subsection{Bubble Sort}
			\lstinputlisting{algoritmos/bubblesort.cpp}
		\subsection{Merge Sort}
			\lstinputlisting{algoritmos/mergesort.cpp}
		\subsection{Quicksort}
			\lstinputlisting{algoritmos/quicksort.cpp}
		\subsection{Counting Sort}
			\lstinputlisting{algoritmos/countingsort.cpp}
	
	\section{Matemática}
		\subsection{Bigmod}
			Propriedade:
			\[ (A \cdot B \cdot C) \bmod N = ((A \bmod N) \cdot (B \bmod N) \cdot (C \bmod N)) \bmod N \]
			\[ r = b^p \bmod m \]
			\lstinputlisting{algoritmos/bigmod.cpp}
		\subsection{Long Integer}
			\lstinputlisting{algoritmos/bignum.cpp}
		\subsection{Sieve de Números Primos}
			\lstinputlisting{algoritmos/sieve.cpp}
		\subsection{Máximo Divisor Comum}
			\lstinputlisting{algoritmos/gcd.cpp}
		\subsection{Mínimo Múltiplo Comum}
			\lstinputlisting{algoritmos/mmc.cpp}
		\subsection{Algoritmo de Euclides}
			\lstinputlisting{algoritmos/euclides.cpp}
		\subsection{Combinação}
			\[ C_n^k = {n! \over {k! \cdot (n - k)!}} \]
			\lstinputlisting{algoritmos/comb.cpp}
		\subsection{Floyd's Cycle-Finding}
			\lstinputlisting{algoritmos/floydcycle.cpp}
		\subsection{Matrizes}
			\subsubsection{Decomposição LUP}
				Determina uma decomposição LUP para a matriz \(A\): \( PA = LU \)
				Tempo: \( \Theta(n^3) \)
				\lstinputlisting{algoritmos/lup-decomposition.cpp}
			\subsubsection{Determinante}
				\lstinputlisting{algoritmos/determinante.cpp}
			\subsubsection{Sistemas Lineares}
				Resolve um sistema de equações lineares da forma \(Ax = B\)
				\lstinputlisting{algoritmos/sistlinear.cpp}

	\section{Grafos}
		\subsection{Strongly Connected Components}
			\subsubsection{Kosaraju}
				Tempo: \( O(V + E) \)
				\lstinputlisting{algoritmos/kosaraju.cpp}
			\subsubsection{Tarjan}
				\lstinputlisting{algoritmos/tarjan.cpp}
		\subsection{Caminho mínimo}
			\subsubsection{Floyd-Warshall}
				Tempo: \( \Theta(n^3)\)
				\lstinputlisting{algoritmos/floyd-warshall.cpp}
			\subsubsection{Dijkstra}
				Tempo: \( O(|V|^2) \)
				\lstinputlisting{algoritmos/dijkstra.cpp}
			\subsubsection{Dijkstra com Heap}
				Tempo: \( O(|E| + |V| \log |V|) \)
				% TODO
			\subsubsection{Bellman-Ford}
				Tempo: \( O(|V| |E|) \)
				\lstinputlisting{algoritmos/bellman-ford.cpp}
		\subsection{Árvore Geradora Mínima}
			\subsubsection{Prim}
				% TODO
			\subsubsection{Kruskal}
				Tempo: \( O(|E| \log |V|) \) ou \( O(|E| \cdot \alpha(|V|)) \) caso as arestas estejam pré-ordenadas.
				\lstinputlisting{algoritmos/kruskal.cpp}
			\subsubsection{Boruvka}
				% TODO
		\subsection{Fluxo Máximo e Corte Mínimo}
			\subsubsection{Edmonds-Karp}
				Tempo: \( O(n!) \) % TODO: arrumar o tempo
				\lstinputlisting{algoritmos/ford-fulkerson.cpp}
			\subsubsection{Stoer-Wagner}
				Algoritmo para encontrar o corte mínimo (não s-t) em um grafo. A implementação abaixo é \(O(n^3)\).
				\lstinputlisting{algoritmos/stoer-wagner.cpp}
			\subsubsection{Min-Cost Max-Flow}
				Tempo: \( O(min(n^2 m \cdot fcost, ~ n m \cdot flow) ) \)
				\lstinputlisting{algoritmos/mincostmaxflow.cpp}
			\subsubsection{Kuhn-Munkres}
				Dado um grafo completo bipartido com pesos $ G = (X \cup Y, X \times Y) $, encontra um matching $M$ de $X$ para $Y$ com peso total máximo. Para encontrar com peso mínimo, basta negar todos os custos.

				Tempo: \( O(n^3) \)
				\lstinputlisting{algoritmos/kuhn-munkres.cpp}
		\subsection{Aresta de Corte}
			\lstinputlisting{algoritmos/bridge.cpp}
		\subsection{Ponto de Articulação}
			\lstinputlisting{algoritmos/pontoart.cpp}
		\subsection{Caminho Euleriano}
			% TODO
		\subsection{Ciclo Euleriano}
			% TODO
		\subsection{Fatos Interessantes}
			\begin{enumerate}
				\item Um grafo é bipartido se e somente se não tem ciclo ímpar.
				\item \textbf{Teorema de Euler}. Para qualquer grafo planar, \( V - E + F = 1 + C \), onde \(V\) é o número de vértices do grafo, \(E\) é o número de arestas, \(F\) é o número de faces do grafo em um desenho planar e \(C\) é o número de componentes conexas.
				\item \textbf{Teorema de Kirchhoff}. Seja a matriz \( T = [ t_{ij} ] \), onte \( t_{ij} \) é o número de arestas entre \(i\) e \(j\), para \( i \neq j \), e \( t_{ii} = - deg_i \). O número de árvores geradoras de um grafo é igual ao determinante de uma matriz obtida ao deletar qualquer \emph{k}-ésima linha e \emph{k}-ésima coluna de \(T\).
			\end{enumerate}

	\section{Programação Dinâmica}
		% TODO: colocar mais
		\subsection{Longest Common Subsequence}
			Tempo: \( O(nm) \)
			\lstinputlisting{algoritmos/lcs.cpp}
		\subsection{Longest Increasing Subsequence}
			Tempo: \( O(nlogn) \)
			\lstinputlisting{algoritmos/lis.cpp}
		\subsection{Matrix-chain Multiplication}
			Tempo: \( O(n^3) \)
			\lstinputlisting{algoritmos/arraymultiplication.cpp}
		\subsection{0-1 Knapsack}
		\subsection{CYK}
			Tempo: \( O(n^3) \)
			% TODO	
	\section{Geometria Computacional}
		\lstinputlisting{algoritmos/geometry-defs.cpp}
		\subsection{Círculos}
			\lstinputlisting{algoritmos/circle.cpp}
		\subsection{Intersecção de Segmentos}
			\lstinputlisting{algoritmos/segments-intersect.cpp}
		\subsection{Ponto dentro de Polígono}
			\subsubsection{Solução 1}
				Constante de tempo baixa, não faz uso de funções de trigonometria. Retorna \emph{true} se o ponto está sob um dos lados do polígono (facilmente alterável).
				\lstinputlisting{algoritmos/inpoly1.cpp}
		\subsection{Teste de Convexidade}
			Algoritmo para testar se um polígono é convexo ou não.
			% TODO
		\subsection{Área de um Polígono}
			\subsubsection{Convexo}
				Se o polígono está no sentido anti-horário, a área é positiva. Se estiver no sentido horário, a área é negativa.
				\lstinputlisting{algoritmos/convex-area.cpp}
			\subsubsection{Qualquer}
				\lstinputlisting{algoritmos/poly-area.cpp}
		\subsection{Convex Hull}
			\subsubsection{Graham Scan}
				Tempo: \(O(n \log n)\)
				\lstinputlisting{algoritmos/graham-scan.cpp}
			\subsubsection{Jarvis March}
				Tempo: \(O(n h)\)
				\lstinputlisting{algoritmos/jarvis-march.cpp}
		\subsection{Closest Pair of Points}
			% TODO

	\section{Outros}
		\subsection{2-SAT}
			\[ (a_1 \vee a_2) \wedge (b_1 \vee b_2) \wedge \ldots \wedge (z_1 \vee z_2) \]
			Para determinar se uma fórmula com duas literais por cláusula é satisfazível, basta:
			\begin{enumerate}
				\item Trocar cada cláusula $ (x_1 \vee x_2) $ por $ (\neg x_1 \rightarrow x_2) \wedge (\neg x_2 \rightarrow x_1) $.
				\item Criar um grafo $G$:
				\begin{enumerate}
					\item Para cada literal $x$, criar um nó $x$ e $\neg x$.
					\item Para cada cláusula $ (a \rightarrow b) $, criar uma aresta $(a, b)$ no grafo.
				\end{enumerate}
				\item Encontrar \emph{SCC} do grafo $G$.
				\item Se todo literal $x$ estiver em uma \emph{SCC} diferente de $\neg x$, a formula é satisfazível.
			\end{enumerate}
			Caso exista uma cláusula com apenas um literal $x$, basta trocá-la por $(1 \vee x)$ e, portanto, criar os nós $0$ e $1$ e as arestas:
			\begin{enumerate}
				\item $(0, 1)$.
				\item $(0, a)$, $(0, \neg a)$, $(a, 1)$ e $(\neg a, 1)$ para \emph{todos} os literais $a$ da fórmula.
				\item Obviamente, $(1, x)$ e $(\neg x, 0)$.
			\end{enumerate}
		\subsection{Sist. de restrições de diferenças}
			Dado um sistema de $n$ incógnitas $x_i$ ($1 \leq i \leq n$) com $m$ inequações na forma $ x_j - x_i \leq b_k $, modela-se um grafo com $V = \{v_0, v_1, \ldots, v_n\} $, uma aresta $(v_i, v_j)$ para cada inequação $x_j - x_i \leq b_k$, com $w(v_i, v_j) = v_k$ e uma aresta $(v_0, v_i)$, com $w(v_0, v_i) = 0$ para cada $v_i \in V - \{v_0\}$.
			
			Por fim, rodar Bellman-Ford no grafo construído, caso existam ciclos negativos, não há solução para o sistema. Caso não existam ciclos negativos, uma solução factível para o sistema é $(x_1 = \delta(v_0, v_1), x_2 = \delta(v_0, v_1), \ldots, x_n = \delta(v_0, v_n))$.

			O algoritmo minimiza $\sum_{i=1}^n x_i$ e $\max\{x_i\} - \min\{x_i\}$, sujeito às restrições e $x_i \leq 0$.

			Mais informações no Cormen, p. 602.
		\subsection{Kadane 1D}
			Tempo: \(\Theta(n)\)
			\lstinputlisting{algoritmos/kadane1d.cpp}
		\subsection{Kadane 2D}
			Tempo: \(O(n^3)\)
			\lstinputlisting{algoritmos/kadane2d.cpp}
		\subsection{Majority Problem}
			Encontra o elemento que aparece em mais da metade de um array em \(\Theta(n)\)
			\lstinputlisting{algoritmos/majority.cpp}
		\subsection{Stable Marriage}
			Given $n$ men and $n$ women, where each person has ranked all members of the opposite sex with a unique number between $1$ and $n$ in order of preference, marry the men and women off such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are \emph{stable}.
			\subsubsection{Gale-Shapley}
				Tempo: \(O(n^2)\)
				\lstinputlisting{algoritmos/stablemarriage.cpp}
		\subsection{Números Romanos}
			\lstinputlisting{algoritmos/romanos.cpp}
		\subsection{Calendário}
			\lstinputlisting{algoritmos/calendario.cpp}
		\subsection{Josephus Problem}
			% TODO

	\twocolumn
	\section{Formulário}
		\subsection{Somatórios}
			\[ \sum_{k = 1}^{n} k = \frac{n \cdot (n + 1)}{2} \]
			\[ \sum_{k = 1}^{n} k^2 = \frac{n \cdot (n + 1) \cdot (2n + 1)}{6} \]
			\[ \sum_{k = 1}^{n} k^3 = \bigg[\frac{n \cdot (n + 1)}{2}\bigg]^2 \]
		\subsection{Geometria}
			\subsubsection{Triângulos}
				\emph{Área, dados lados a, b, c}
				\[ S = \sqrt{p (p - a) (p - b) (p - c)} \]
				\[ p = \frac{a + b + c}{2} \]
				\emph{Área, dadas medianas u, v, w}
				\[ S = \frac{4}{3} \sqrt{q (q - u) (q - v) (q - w)} \]
				\[ q = \frac{u + v + w}{2} \]

	\onecolumn
	\section{Troubleshooting}
		\subsection{Erros Comuns}
			\begin{enumerate}
				\item Overflow?
				\item Verificar iteradores de todos os fors.
				\item Verificar limites de arrays.
				\item Modificando container STL enquanto iterando sobre ele?
				\item \emph{Nunca} fazer $strcmp == -1$, sempre $strcmp < 0$!
				\item Tem alguma função que era pra retornar algo que não tá retornando nada? Cuidado, C++ não reclama da falta de $return$!
			\end{enumerate}
			\subsubsection{Wrong Answer}
				\begin{enumerate}
					\item Overflow?
					\item As variáveis estão todas sendo inicializadas/zeradas? O programa dá a mesma resposta para casos repetidos?
					\item Array pequeno demais? Programa pode estar escrevendo no endereço de memória de outra variável e fazendo algo bizarro.
				\end{enumerate}
			\subsubsection{Runtime Error}
				\begin{enumerate}
					\item Dividiu por zero? Fez módulo por zero?
					\item Array out of bounds?
					\item Arrays grandes demais? Usando memória demais?
					\item Função recursiva que não termina nunca?
					\item Stack overflow? Arrays grandes demais? Colocar os arrays gigantes como globais, nunca locais.
					\item Alocando memória sem liberar? Memory leak?
				\end{enumerate}
			\subsubsection{Time Limit Exceeded}
				\begin{enumerate}
					\item Loop infinito?
					\item Evitar recálculo (i/w, i\%w)
					\item Usando STL desnecessariamente?
					\item Descubra qual parte do codigo demora mais.
				\end{enumerate}
		\subsection{Grafos}
			\begin{enumerate}
				\item O grafo é dirigido?
				\item O grafo pode ser desconexo?
				\item O grafo possui arestas paralelas? Arestas repetidas? Arestas $(v_i,v_i)$?
				\item As arestas podem ter pesos negativos?
				\item Dá pra otimizar o Dijkstra? Usar heap no braço? Alguma heurística pra transformar em A*?
				\item Zerou $deg[]$, $vis[]$, etc?
			\end{enumerate}
\end{document}
